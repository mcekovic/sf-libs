package org.strangeforest.db;

import java.sql.*;

import org.strangeforest.util.*;

/**
 * <p>This is a wrapper around statement implementation.</p>
 */
public class StatementHelper implements Statement {

	protected Statement st;
	protected String sql;
	protected PooledConnection conn;
	protected ConnectionPoolLogger logger;
	protected long start, end;

	protected StatementHelper() {
		super();
	}

	public StatementHelper(Statement st) {
		super();
		this.st = st;
	}

	StatementHelper(PooledConnection conn, Statement st) {
		super();
		this.conn = conn;
		this.st = st;
		this.logger = conn.getLogger();
		conn.setLastStatement(this);
	}


	// Helper methods

	public ConnectionPoolLogger getLogger() {
		return logger;
	}

	public void setLogger(ConnectionPoolLogger logger) {
		this.logger = logger;
	}


	// Statement methods

	@Override public void addBatch(String sql) throws SQLException {
		st.addBatch(sql);
		this.sql = StringUtil.appendLine(this.sql, sql);
	}

	@Override public void cancel() throws SQLException {
		st.cancel();
	}

	@Override public void clearBatch() throws SQLException {
		st.clearBatch();
	}

	@Override public void clearWarnings() throws SQLException {
		st.clearWarnings();
	}

	@Override public void close() throws SQLException {
		st.close();
	}

	@Override public boolean execute(String sql) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		boolean result = st.execute(sql);
		end = System.currentTimeMillis();
		logStatement();
		return result;
	}

	@Override public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		boolean result = st.execute(sql, autoGeneratedKeys);
		end = System.currentTimeMillis();
		logStatement();
		return result;
	}

	@Override public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		boolean result = st.execute(sql, columnIndexes);
		end = System.currentTimeMillis();
		logStatement();
		return result;
	}

	@Override public boolean execute(String sql, String[] columnNames) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		boolean result = st.execute(sql, columnNames);
		end = System.currentTimeMillis();
		logStatement();
		return result;
	}

	@Override public int[] executeBatch() throws SQLException {
		start = System.currentTimeMillis();
		end = 0L;
		int[] updateCounts = st.executeBatch();
		end = System.currentTimeMillis();
		logStatement();
		return updateCounts;
	}

	@Override public ResultSet executeQuery(String sql) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		ResultSet rs = st.executeQuery(sql);
		end = System.currentTimeMillis();
		logStatement();
		return rs;
	}

	@Override public int executeUpdate(String sql) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		int updateCount = st.executeUpdate(sql);
		end = System.currentTimeMillis();
		logStatement();
		return updateCount;
	}

	@Override public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		int updateCount = st.executeUpdate(sql, autoGeneratedKeys);
		end = System.currentTimeMillis();
		logStatement();
		return updateCount;
	}

	@Override public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		int updateCount = st.executeUpdate(sql, columnIndexes);
		end = System.currentTimeMillis();
		logStatement();
		return updateCount;
	}

	@Override public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		int updateCount = st.executeUpdate(sql, columnNames);
		end = System.currentTimeMillis();
		logStatement();
		return updateCount;
	}

	@Override public Connection getConnection() throws SQLException {
		return st.getConnection();
	}

	@Override public int getFetchDirection() throws SQLException {
		return st.getFetchDirection();
	}

	@Override public int getFetchSize() throws SQLException {
		return st.getFetchSize();
	}

	@Override public ResultSet getGeneratedKeys() throws SQLException {
		return st.getGeneratedKeys();
	}

	@Override public int getMaxFieldSize() throws SQLException {
		return st.getMaxFieldSize();
	}

	@Override public int getMaxRows() throws SQLException {
		return st.getMaxRows();
	}

	@Override public boolean getMoreResults() throws SQLException {
		return st.getMoreResults();
	}

	@Override public boolean getMoreResults(int current) throws SQLException {
		return st.getMoreResults(current);
	}

	@Override public int getQueryTimeout() throws SQLException {
		return st.getQueryTimeout();
	}

	@Override public ResultSet getResultSet() throws SQLException {
		return st.getResultSet();
	}

	@Override public int getResultSetConcurrency() throws SQLException {
		return st.getResultSetConcurrency();
	}

	@Override public int getResultSetHoldability() throws SQLException {
		return st.getResultSetHoldability();
	}

	@Override public int getResultSetType() throws SQLException {
		return st.getResultSetType();
	}

	@Override public int getUpdateCount() throws SQLException {
		return st.getUpdateCount();
	}

	@Override public SQLWarning getWarnings() throws SQLException {
		return st.getWarnings();
	}

	@Override public boolean isClosed() throws SQLException {
		return st.isClosed();
	}

	@Override public boolean isPoolable() throws SQLException {
		return st.isPoolable();
	}

	@Override public void closeOnCompletion() throws SQLException {
		st.closeOnCompletion();
	}

	@Override public boolean isCloseOnCompletion() throws SQLException {
		return st.isCloseOnCompletion();
	}

	@Override public void setCursorName(String name) throws SQLException {
		st.setCursorName(name);
	}

	@Override public void setEscapeProcessing(boolean enable) throws SQLException {
		st.setEscapeProcessing(enable);
	}

	@Override public void setFetchDirection(int direction) throws SQLException {
		st.setFetchDirection(direction);
	}

	@Override public void setFetchSize(int rows) throws SQLException {
		st.setFetchSize(rows);
	}

	@Override public void setMaxFieldSize(int max) throws SQLException {
		st.setMaxFieldSize(max);
	}

	@Override public void setMaxRows(int max) throws SQLException {
		st.setMaxRows(max);
	}

	@Override public void setPoolable(boolean poolable) throws SQLException {
		st.setPoolable(poolable);
	}

	@Override public void setQueryTimeout(int seconds) throws SQLException {
		st.setQueryTimeout(seconds);
	}

	@Override public <T> T unwrap(Class<T> iface) throws SQLException {
		return iface.isInterface() && iface.isInstance(this) ? (T)this : st.unwrap(iface);
	}

	@Override public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return (iface.isInterface() && iface.isInstance(this)) || st.isWrapperFor(iface);
	}


	// Misc

	@Override public String toString() {
		if (sql != null) {
			StringBuilder sb = new StringBuilder();
			format(sb);
			return sb.toString();
		}
		else
			return super.toString();
	}

	protected void format(StringBuilder sb) {
		sb.append(getClass().getSimpleName());
		sb.append(" [");
		sb.append((end != 0L ? end : System.currentTimeMillis()) - start);
		sb.append("ms]:\n");
		sb.append(removeLWS(sql));
		sb.append('\n');
	}

	protected static String removeLWS(String s) {
		char[] chars = s.toCharArray();
		StringBuilder sb = new StringBuilder(s.length());
		boolean isLWS = true;
		for (char c : chars) {
			if (isLWS) {
				if (!Character.isWhitespace(c)) {
					isLWS = false;
					sb.append(c);
				}
			}
			else {
				if (c == '\n' || c == '\r')
					isLWS = true;
				sb.append(c);
			}
		}
		return sb.toString();
	}

	protected void logStatement() {
		if (logger != null)
			logger.logStatement(this);
		updateStats();
	}

	protected final void updateStats() {
		if (conn != null)
			conn.getConnectionPool().updateStatementStats(this);
	}
}
