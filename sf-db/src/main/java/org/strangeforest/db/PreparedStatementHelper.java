package org.strangeforest.db;

import java.util.*;
import java.io.*;
import java.math.*;
import java.net.*;
import java.sql.*;

import org.strangeforest.util.*;

/**
 * <p>This is a helper class that allows setting <tt>PreparedStatement</tt> parameters by name.</p>
 * <p>In SQL query text, parameter names are added as suffixes to ':' or '?'.
 * <p>For example:</p>
 * <blockquote><pre>
 * Connection conn = ...
 * String sql = "INSERT INTO DEPARTMENT (ID, NAME) VALUES (:id, :name)";
 * PreparedStatementHelper st = new PreparedStatementHelper(conn, sql);
 * // or PreparedStatementHelper st = (PreparedStatementHelper)conn.prepareStatement(sql); // if conn is from ConnectionPool
 * st.setInt("id", id);
 * st.setString("name", name);
 * st.executeUpdate();
 * st.close();
 * ...
 * </pre></blockquote>
 */
public class PreparedStatementHelper extends StatementHelper implements PreparedStatement {

	protected PreparedStatement pst;
	protected final Map<String, ParamInfo> paramMap;
	private Map<String, ParamInfo> indexParamMap;
	private List<Map<String, ParamInfo>> batchedParams;
	private ResultSet rs;
	private Object key;
	private boolean pooled;

	public PreparedStatementHelper(Connection conn, String sql) throws SQLException {
		super();
		paramMap = new HashMap<>();
		createStatement(conn, sql);
	}

	public PreparedStatementHelper(Connection conn, String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
		super();
		paramMap = new HashMap<>();
		createStatement(conn, sql, resultSetType, resultSetConcurrency);
	}

	public PreparedStatementHelper(Connection conn, String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
		super();
		paramMap = new HashMap<>();
		createStatement(conn, sql, resultSetType, resultSetConcurrency, resultSetHoldability);
	}

	public PreparedStatementHelper(Connection conn, String sql, int autoGeneratedKeys) throws SQLException {
		super();
		paramMap = new HashMap<>();
		createStatement(conn, sql, autoGeneratedKeys);
	}

	public PreparedStatementHelper(Connection conn, String sql, int[] columnIndexes) throws SQLException {
		super();
		paramMap = new HashMap<>();
		createStatement(conn, sql, columnIndexes);
	}

	public PreparedStatementHelper(Connection conn, String sql, String[] columnNames) throws SQLException {
		super();
		paramMap = new HashMap<>();
		createStatement(conn, sql, columnNames);
	}

	PreparedStatementHelper(PooledConnection conn, Object key, String sql) throws SQLException {
		super();
		this.conn = conn;
		this.key = key;
		pooled = key != null;
		paramMap = new HashMap<>();
		logger = conn.getLogger();
		conn.setLastStatement(this);
		createStatement(conn.getConnection(), sql);
	}

	PreparedStatementHelper(PooledConnection conn, Object key, String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
		super();
		this.conn = conn;
		this.key = key;
		pooled = key != null;
		paramMap = new HashMap<>();
		logger = conn.getLogger();
		conn.setLastStatement(this);
		createStatement(conn.getConnection(), sql, resultSetType, resultSetConcurrency);
	}

	PreparedStatementHelper(PooledConnection conn, Object key, String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
		super();
		this.conn = conn;
		this.key = key;
		pooled = key != null;
		paramMap = new HashMap<>();
		logger = conn.getLogger();
		conn.setLastStatement(this);
		createStatement(conn.getConnection(), sql, resultSetType, resultSetConcurrency, resultSetHoldability);
	}

	PreparedStatementHelper(PooledConnection conn, Object key, String sql, int autoGeneratedKeys) throws SQLException {
		super();
		this.conn = conn;
		this.key = key;
		pooled = key != null;
		paramMap = new HashMap<>();
		logger = conn.getLogger();
		conn.setLastStatement(this);
		createStatement(conn.getConnection(), sql, autoGeneratedKeys);
	}

	PreparedStatementHelper(PooledConnection conn, Object key, String sql, int[] columnIndexes) throws SQLException {
		super();
		this.conn = conn;
		this.key = key;
		pooled = key != null;
		paramMap = new HashMap<>();
		logger = conn.getLogger();
		conn.setLastStatement(this);
		createStatement(conn.getConnection(), sql, columnIndexes);
	}

	PreparedStatementHelper(PooledConnection conn, Object key, String sql, String[] columnNames) throws SQLException {
		super();
		this.conn = conn;
		this.key = key;
		pooled = key != null;
		paramMap = new HashMap<>();
		logger = conn.getLogger();
		conn.setLastStatement(this);
		createStatement(conn.getConnection(), sql, columnNames);
	}

	protected void createStatement(Connection conn, String sql) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		pst = conn.prepareStatement(parse(sql));
		st = pst;
	}

	protected void createStatement(Connection conn, String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		pst = conn.prepareStatement(parse(sql), resultSetType, resultSetConcurrency);
		st = pst;
	}

	protected void createStatement(Connection conn, String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		pst = conn.prepareStatement(parse(sql), resultSetType, resultSetConcurrency, resultSetHoldability);
		st = pst;
	}

	protected void createStatement(Connection conn, String sql, int autoGeneratedKeys) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		pst = conn.prepareStatement(parse(sql), autoGeneratedKeys);
		st = pst;
	}

	protected void createStatement(Connection conn, String sql, int[] columnIndexes) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		pst = conn.prepareStatement(parse(sql), columnIndexes);
		st = pst;
	}

	protected void createStatement(Connection conn, String sql, String[] columnNames) throws SQLException {
		this.sql = sql;
		start = System.currentTimeMillis();
		end = 0L;
		pst = conn.prepareStatement(parse(sql), columnNames);
		st = pst;
	}


	// PreparedStatement methods

	@Override public void addBatch() throws SQLException {
		pst.addBatch();
		if (batchedParams == null)
			batchedParams = new ArrayList<>();
		Map<String, ParamInfo> batchedParamMap = new HashMap<>();
		copyParams(paramMap, batchedParamMap);
		if (indexParamMap != null)
			copyParams(indexParamMap, batchedParamMap);
		batchedParams.add(batchedParamMap);
	}

	private void copyParams(Map<String, ParamInfo> fromParamMap, Map<String, ParamInfo> toParamMap) {
		for (Map.Entry<String, ParamInfo> param : fromParamMap.entrySet())
			toParamMap.put(param.getKey(), param.getValue().clone());
	}

	@Override public void clearParameters() throws SQLException {
		for (ParamInfo info : paramMap.values()) {
			info.value = null;
			info.masked = false;
		}
		if (indexParamMap != null)
			indexParamMap.clear();
		batchedParams = null;
		pst.clearParameters();
	}

	@Override public boolean execute() throws SQLException {
		boolean result = pst.execute();
		end = System.currentTimeMillis();
		logStatement();
		return result;
	}

	@Override public ResultSet executeQuery() throws SQLException {
		rs = pst.executeQuery();
		end = System.currentTimeMillis();
		logStatement();
		return rs;
	}

	@Override public int executeUpdate() throws SQLException {
		int updateCount = pst.executeUpdate();
		end = System.currentTimeMillis();
		logStatement();
		return updateCount;
	}

	@Override public int[] executeBatch() throws SQLException {
		int[] updateCount = super.executeBatch();
		batchedParams = null;
		return updateCount;
	}

	@Override public ResultSetMetaData getMetaData() throws SQLException {
		return pst.getMetaData();
	}

	@Override public ParameterMetaData getParameterMetaData() throws SQLException {
		return new ParameterMetaDataHelper(this, pst.getParameterMetaData());
	}

	@Override public void setArray(int index, Array x) throws SQLException {
		setParam(index, x);
		pst.setArray(index, x);
	}

	@Override public void setAsciiStream(int index, InputStream x) throws SQLException {
		setParam(index, x);
		pst.setAsciiStream(index, x);
	}

	@Override public void setAsciiStream(int index, InputStream x, int length) throws SQLException {
		setParam(index, x);
		pst.setAsciiStream(index, x, length);
	}

	@Override public void setAsciiStream(int index, InputStream x, long length) throws SQLException {
		setParam(index, x);
		pst.setAsciiStream(index, x, length);
	}

	@Override public void setBigDecimal(int index, BigDecimal x) throws SQLException {
		setParam(index, x);
		pst.setBigDecimal(index, x);
	}

	@Override public void setBinaryStream(int index, InputStream x) throws SQLException {
		setParam(index, x);
		pst.setBinaryStream(index, x);
	}

	@Override public void setBinaryStream(int index, InputStream x, int length) throws SQLException {
		setParam(index, x);
		pst.setBinaryStream(index, x, length);
	}

	@Override public void setBinaryStream(int index, InputStream x, long length) throws SQLException {
		setParam(index, x);
		pst.setBinaryStream(index, x, length);
	}

	@Override public void setBlob(int index, Blob x) throws SQLException {
		setParam(index, x);
		pst.setBlob(index, x);
	}

	@Override public void setBlob(int index, InputStream x) throws SQLException {
		setParam(index, x);
		pst.setBlob(index, x);
	}

	@Override public void setBoolean(int index, boolean x) throws SQLException {
		setParam(index, x);
		pst.setBoolean(index, x);
	}

	@Override public void setByte(int index, byte x) throws SQLException {
		setParam(index, x);
		pst.setByte(index, x);
	}

	@Override public void setBytes(int index, byte[] x) throws SQLException {
		setParam(index, x);
		pst.setBytes(index, x);
	}

	@Override public void setBlob(int index, InputStream x, long length) throws SQLException {
		setParam(index, x);
		pst.setBlob(index, x, length);
	}

	@Override public void setCharacterStream(int index, Reader x) throws SQLException {
		setParam(index, x);
		pst.setCharacterStream(index, x);
	}

	@Override public void setCharacterStream(int index, Reader x, int length) throws SQLException {
		setParam(index, x);
		pst.setCharacterStream(index, x, length);
	}

	@Override public void setCharacterStream(int index, Reader x, long length) throws SQLException {
		setParam(index, x);
		pst.setCharacterStream(index, x, length);
	}

	@Override public void setClob(int index, Clob x) throws SQLException {
		setParam(index, x);
		pst.setClob(index, x);
	}

	@Override public void setClob(int index, Reader x) throws SQLException {
		setParam(index, x);
		pst.setClob(index, x);
	}

	@Override public void setClob(int index, Reader x, long length) throws SQLException {
		setParam(index, x);
		pst.setClob(index, x, length);
	}

	@Override public void setDate(int index, java.sql.Date x) throws SQLException {
		setParam(index, x);
		pst.setDate(index, x);
	}

	@Override public void setDate(int index, java.sql.Date x, Calendar cal) throws SQLException {
		setParam(index, x);
		pst.setDate(index, x, cal);
	}

	@Override public void setDouble(int index, double x) throws SQLException {
		setParam(index, x);
		pst.setDouble(index, x);
	}

	@Override public void setFloat(int index, float x) throws SQLException {
		setParam(index, x);
		pst.setFloat(index, x);
	}

	@Override public void setInt(int index, int x) throws SQLException {
		setParam(index, x);
		pst.setInt(index, x);
	}

	@Override public void setLong(int index, long x) throws SQLException {
		setParam(index, x);
		pst.setLong(index, x);
	}

	@Override public void setNCharacterStream(int index, Reader x) throws SQLException {
		setParam(index, x);
		pst.setNCharacterStream(index, x);
	}

	@Override public void setNCharacterStream(int index, Reader x, long length) throws SQLException {
		setParam(index, x);
		pst.setNCharacterStream(index, x, length);
	}

	@Override public void setNClob(int index, NClob x) throws SQLException {
		setParam(index, x);
		pst.setNClob(index, x);
	}

	@Override public void setNClob(int index, Reader x) throws SQLException {
		setParam(index, x);
		pst.setNClob(index, x);
	}

	@Override public void setNClob(int index, Reader x, long length) throws SQLException {
		setParam(index, x);
		pst.setNClob(index, x, length);
	}

	@Override public void setNString(int index, String x) throws SQLException {
		setParam(index, x);
		pst.setNString(index, x);
	}

	@Override public void setNull(int index, int sqlType) throws SQLException {
		setParam(index, null);
		pst.setNull(index, sqlType);
	}

	@Override public void setNull(int index, int sqlType, String typeName) throws SQLException {
		setParam(index, null);
		pst.setNull(index, sqlType, typeName);
	}

	@Override public void setObject(int index, Object x) throws SQLException {
		setParam(index, x);
		pst.setObject(index, x);
	}

	@Override public void setObject(int index, Object x, int targetSqlType) throws SQLException {
		setParam(index, x);
		pst.setObject(index, x, targetSqlType);
	}

	@Override public void setObject(int index, Object x, int targetSqlType, int scale) throws SQLException {
		setParam(index, x);
		pst.setObject(index, x, targetSqlType, scale);
	}

	@Override public void setRef(int index, Ref x) throws SQLException {
		setParam(index, x);
		pst.setRef(index, x);
	}

	@Override public void setRowId(int index, RowId x) throws SQLException {
		setParam(index, x);
		pst.setRowId(index, x);
	}

	@Override public void setShort(int index, short x) throws SQLException {
		setParam(index, x);
		pst.setShort(index, x);
	}

	@Override public void setString(int index, String x) throws SQLException {
		setParam(index, x);
		pst.setString(index, x);
	}

	@Override public void setSQLXML(int index, SQLXML x) throws SQLException {
		setParam(index, x);
		pst.setSQLXML(index, x);
	}

	@Override public void setTime(int index, Time x) throws SQLException {
		setParam(index, x);
		pst.setTime(index, x);
	}

	@Override public void setTime(int index, Time x, Calendar cal) throws SQLException {
		setParam(index, x);
		pst.setTime(index, x, cal);
	}

	@Override public void setTimestamp(int index, Timestamp x) throws SQLException {
		setParam(index, x);
		pst.setTimestamp(index, x);
	}

	@Override public void setTimestamp(int index, Timestamp x, Calendar cal) throws SQLException {
		setParam(index, x);
		pst.setTimestamp(index, x, cal);
	}

	@Override public void setUnicodeStream(int index, InputStream x, int length) throws SQLException {
		setParam(index, x);
		pst.setUnicodeStream(index, x, length);
	}

	@Override public void setURL(int index, URL x) throws SQLException {
		setParam(index, x);
		pst.setURL(index, x);
	}


	// Statement methods

	@Override public void close() throws SQLException {
		if (!pooled) {
			if (conn != null) // Removal from PooledConnection must be in close() as removal closes wrapped statement
				conn.removeStatement(key);
			pst.close();
		}
		else if (rs != null) {
			try {
				rs.close();
			}
			catch (SQLException ignored) {}
			rs = null;
		}
	}

	@Override public ResultSet executeQuery(String sql) throws SQLException {
		rs = super.executeQuery(sql);
		return rs;
	}

	@Override public ResultSet getGeneratedKeys() throws SQLException {
		rs = super.getGeneratedKeys();
		return rs;
	}

	@Override public ResultSet getResultSet() throws SQLException {
		rs = super.getResultSet();
		return rs;
	}

	@Override public void setPoolable(boolean poolable) throws SQLException {
		pooled = poolable;
		super.setPoolable(poolable);
	}


	// Helper methods

	public boolean isMasked(String paramName) {
		return getParamInfo(paramName).masked;
	}

	public void setMasked(String paramName, boolean masked) {
		getParamInfo(paramName).masked = masked;
	}

	public int getType(String paramName) throws SQLException {
		return pst.getMetaData().getColumnType(getParamInfo(paramName).getIndex());
	}

	public void setArray(String paramName, Array x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setArray(index, x);
	}

	public void setAsciiStream(String paramName, InputStream x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setAsciiStream(index, x);
	}

	public void setAsciiStream(String paramName, InputStream x, int length) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setAsciiStream(index, x, length);
	}

	public void setAsciiStream(String paramName, InputStream x, long length) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setAsciiStream(index, x, length);
	}

	public void setBigDecimal(String paramName, BigDecimal x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setBigDecimal(index, x);
	}

	public void setBinaryStream(String paramName, InputStream x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setBinaryStream(index, x);
	}

	public void setBinaryStream(String paramName, InputStream x, int length) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setBinaryStream(index, x, length);
	}

	public void setBinaryStream(String paramName, InputStream x, long length) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setBinaryStream(index, x, length);
	}

	public void setBlob(String paramName, Blob x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setBlob(index, x);
	}

	public void setBlob(String paramName, InputStream x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setBlob(index, x);
	}

	public void setBlob(String paramName, InputStream x, long length) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setBlob(index, x, length);
	}

	public void setBoolean(String paramName, boolean x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setBoolean(index, x);
	}

	public void setByte(String paramName, byte x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setByte(index, x);
	}

	public void setBytes(String paramName, byte[] x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setBytes(index, x);
	}

	public void setCharacterStream(String paramName, Reader x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setCharacterStream(index, x);
	}

	public void setCharacterStream(String paramName, Reader x, int length) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setCharacterStream(index, x, length);
	}

	public void setCharacterStream(String paramName, Reader x, long length) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setCharacterStream(index, x, length);
	}

	public void setClob(String paramName, Clob x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setClob(index, x);
	}

	public void setClob(String paramName, Reader x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setClob(index, x);
	}

	public void setClob(String paramName, Reader x, long length) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setClob(index, x, length);
	}

	public void setDate(String paramName, java.sql.Date x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setDate(index, x);
	}

	public void setDate(String paramName, java.sql.Date x, Calendar cal) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setDate(index, x, cal);
	}

	public void setDouble(String paramName, double x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setDouble(index, x);
	}

	public void setFloat(String paramName, float x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setFloat(index, x);
	}

	public void setInt(String paramName, int x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setInt(index, x);
	}

	public void setLong(String paramName, long x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setLong(index, x);
	}

	public void setNCharacterStream(String paramName, Reader x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setNCharacterStream(index, x);
	}

	public void setNCharacterStream(String paramName, Reader x, long length) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setNCharacterStream(index, x, length);
	}

	public void setNClob(String paramName, NClob x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setNClob(index, x);
	}

	public void setNClob(String paramName, Reader x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setNClob(index, x);
	}

	public void setNClob(String paramName, Reader x, long length) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setNClob(index, x, length);
	}

	public void setNString(String paramName, String x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setNString(index, x);
	}

	public void setNull(String paramName, int sqlType) throws SQLException {
		for (int index : getParamInfo(paramName).indices)
			pst.setNull(index, sqlType);
	}

	public void setNull(String paramName, int sqlType, String typeName) throws SQLException {
		for (int index : getParamInfo(paramName).indices)
			pst.setNull(index, sqlType, typeName);
	}

	public void setObject(String paramName, Object x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setObject(index, x);
	}

	public void setObject(String paramName, Object x, int targetSqlType) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setObject(index, x, targetSqlType);
	}

	public void setObject(String paramName, Object x, int targetSqlType, int scale) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setObject(index, x, targetSqlType, scale);
	}

	public void setRef(String paramName, Ref x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setRef(index, x);
	}

	public void setRowId(String paramName, RowId x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setRowId(index, x);
	}

	public void setShort(String paramName, short x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setShort(index, x);
	}

	public void setString(String paramName, String x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setString(index, x);
	}

	public void setSQLXML(String paramName, SQLXML x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setSQLXML(index, x);
	}

	public void setTime(String paramName, Time x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setTime(index, x);
	}

	public void setTime(String paramName, Time x, Calendar cal) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setTime(index, x, cal);
	}

	public void setTimestamp(String paramName, Timestamp x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setTimestamp(index, x);
	}

	public void setTimestamp(String paramName, Timestamp x, Calendar cal) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setTimestamp(index, x, cal);
	}

	public void setUnicodeStream(String paramName, InputStream x, int length) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setUnicodeStream(index, x, length);
	}

	public void setURL(String paramName, URL x) throws SQLException {
		ParamInfo info = setParam(paramName, x);
		for (int index : info.indices)
			pst.setURL(index, x);
	}

	public ParameterMetaDataHelper getParameterMetaDataHelper() throws SQLException {
		return new ParameterMetaDataHelper(this, pst.getParameterMetaData());
	}


	// Misc

	void doClose() throws SQLException {
		pst.close();
	}

	void cleanForReuse() {
		try {
			clearParameters();
		}
		catch (Exception ignored) {}
		start = System.currentTimeMillis();
		end = 0L;
	}

	protected String parse(String sql) {
		StringBuilder sb = new StringBuilder();
		int i = 0, paramIndex = 1;
		while (true) {
			int pos = sql.indexOf('?', i);
			if (pos == -1)
				pos = sql.indexOf(':', i);
			if (pos == -1) {
				sb.append(sql.substring(i));
				break;
			}
			sb.append(sql.substring(i, pos));
			int startPos = pos + 1;
			int endPos = startPos;
			while (endPos < sql.length()) {
				char c = sql.charAt(endPos);
				if (!((endPos == startPos && Character.isJavaIdentifierStart(c)) || (endPos > startPos && Character.isJavaIdentifierPart(c))))
					break;
				endPos++;
			}
			if (endPos > startPos) {
				sb.append('?');
				String paramName = sql.substring(startPos, endPos);
				ParamInfo info = paramMap.get(paramName);
				if (info == null) {
					info = new ParamInfo(paramName);
					paramMap.put(paramName, info);
				}
				info.indices.add(paramIndex);
				paramIndex++;
			}
			else
				sb.append(sql.charAt(pos));
			i = endPos;
		}
		return sb.toString();
	}

	protected final int getParamIndex(String paramName) {
		return getParamInfo(paramName).indices.get(0);
	}

	protected final int getOutputParamIndex(String paramName) {
		ParamInfo info = getParamInfo(paramName);
		info.out = true;
		List<Integer> indices = info.indices;
		if (indices.size() > 1)
			throw new IllegalArgumentException("Output parameters must have different names: " + paramName);
		return indices.get(0);
	}

	protected final boolean hasParam(String paramName) {
		return paramMap.containsKey(paramName);
	}

	private ParamInfo getParamInfo(String paramName) {
		ParamInfo info = paramMap.get(paramName);
		if (info == null)
			throw new IllegalArgumentException("Invalid param name: " + paramName);
		return info;
	}

	private void setParam(int paramIndex, Object paramValue) {
		if (indexParamMap == null)
			indexParamMap = new HashMap<>();
		String paramName = String.valueOf(paramIndex);
		indexParamMap.put(paramName, new ParamInfo(paramName, paramValue));
	}

	private ParamInfo setParam(String paramName, Object paramValue) {
		ParamInfo info = getParamInfo(paramName);
		info.value = paramValue;
		return info;
	}

	@Override protected void format(StringBuilder sb) {
		super.format(sb);
		if (batchedParams == null) {
			if (indexParamMap == null || indexParamMap.isEmpty())
				formatParams(sb, paramMap, null);
			else {
				HashMap<String, ParamInfo> allParamMap = new HashMap<>(paramMap);
				allParamMap.putAll(indexParamMap);
				formatParams(sb, allParamMap, null);
			}
		}
		else {
			for (int i = 0; i < batchedParams.size(); i++)
				formatParams(sb, batchedParams.get(i), i+1);
		}
	}

	private void formatParams(StringBuilder sb, Map<String, ParamInfo> paramMap, Integer batchIndex) {
		Collection<ParamInfo> params = paramMap.values();
		if (!params.isEmpty()) {
			List<ParamInfo> paramList = new ArrayList<>(params);
			Collections.sort(paramList);
			sb.append("\nPARAMETERS");
			if (batchIndex != null) {
				sb.append('[');
				sb.append(batchIndex);
				sb.append(']');
			}
			sb.append(":\n");
			for (ParamInfo info : paramList) {
				formatParam(sb, info);
				sb.append('\n');
			}
		}
	}

	protected void formatParam(StringBuilder sb, ParamInfo info) {
		sb.append(info.name);
		sb.append('=');
		formatParamValue(sb, info.value, info.masked);
	}

	protected static void formatParamValue(StringBuilder sb, Object value, boolean masked) {
		if (masked && value != null)
			sb.append(StringUtil.copy('*', value.toString().length()));
		else if (value instanceof ResultSet) {
			ResultSet rs = (ResultSet)value;
			try {
				if (rs.getType() != ResultSet.TYPE_FORWARD_ONLY) {
					sb.append("{\n");
					ResultSetMetaData md = rs.getMetaData();
					while (rs.next()) {
						for (int i = 0, count = md.getColumnCount(); i < count; i++) {
							if (i > 0)
								sb.append(", ");
							sb.append(md.getColumnName(i));
							sb.append('=');
							formatParamValue(sb, rs.getObject(i), false);
						}
					}
					sb.append('}');
					rs.first();
				}
				else
					sb.append(value);
			}
			catch (SQLException ex) {
				sb.append(ex);
			}
		}
		else
			sb.append(value);
	}

	@Override protected void logStatement() {
		if (logger != null)
			logger.logPreparedStatement(this);
		updateStats();
	}


	protected final class ParamInfo implements Comparable<ParamInfo>, Cloneable {

		public String name;
		public Object value;
		public List<Integer> indices;
		public boolean out;
		public volatile boolean masked;

		public ParamInfo(String name) {
			this.name = name;
			indices = new ArrayList<>();
		}

		public ParamInfo(String name, Object value) {
			this.name = name;
			this.value = value;
		}

		private int getIndex() {
			return indices != null ? Collections.min(indices) : Integer.parseInt(name);
		}

		@Override public int compareTo(ParamInfo info) {
			return PrimitiveUtil.compare(getIndex(), info.getIndex());
		}

		@Override public ParamInfo clone() {
			try {
				return (ParamInfo)super.clone();
			}
			catch (CloneNotSupportedException ex) {
				throw new IllegalStateException(ex);
			}
		}
	}
}
